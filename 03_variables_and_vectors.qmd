---
title: "Data Frame Variables and Vectors"
format: html
editor_options: 
  chunk_output_type: console
---

```{r}
# import the dataframe
healthdata <- read.csv("data/nhanes.csv")
```

# Working with Data Frame Variables

We can access individual variables from a data frame using the syntax of `dataframe_name$variable_name`. For example:

```{r}
healthdata$age
```

By default, this will print out the first 1000 values of the variable.

::: callout-tip
## RStudio Tip: Variable Names

In RStudio, when you type the name of a data frame followed by \$, a menu listing the names of the variables in that data frame will appear. You can select the name from the menu, or keep typing to narrow down the choices before choosing the variable. Hit the tab key to choose the highlighted option.
:::

::: callout-tip
## R Tip: Output Indices

Note when there is a lot of output, the numbers in brackets on the left side (\[1\] and so on) are providing the index position of the first element in that line of output. This always starts with 1, and then the values on the subsequent lines will depend on how much output can fit on a line (varies by the values and the width of your console).
:::

To see just a few values, we can use `head()` like we did with the full data set, optionally specifying the number (`n`) values to show:

```{r}
head(healthdata$age, n=20)
```

An individual variable/column of a data frame is a *vector*. A vector is an ordered list of values all of the same type. Each element of a vector is uniquely identified by its position.

## Using Summary Functions

We can supply variables from the data frame as inputs to functions:

```{r}
mean(healthdata$age)
table(healthdata$gender)
unique(healthdata$survey_year)
length(healthdata$survey_year)  # number of values in the vector
```

## TRY IT

Compute the variance `var()`, standard deviation `sd()`, minimum value `min()`, and maximum value `max()` of the age variable in `healthdata`.

```{r}

```

# Vectorized Functions

Some functions, like `mean()` and `max()` take a vector as input and return a single value. Other functions will operate on each element of the vector individually:

```{r}
log(healthdata$height)
```

Arithmetic operations also affect each element of a vector:

```{r}
healthdata$weight/2.2
```

Basic math operations and comparisons involving two vectors are also performed element-wise:

```{r}
healthdata$height * healthdata$weight  
```

# Missing Values

Vectors can contain missing values. Missing values are represented by `NA` in R:

```{r}
head(healthdata$health_level, n=20)
```

Note in the output that `NA` appears by itself, with no quotation marks around it. It is a special value/symbol, not character data like the other values.

## Missing Values with Functions

When there is missing data in a vector, many summary functions will return `NA` as a result:

```{r}
mean(healthdata$pulse)
max(healthdata$pulse)
```

The `mean()` and `max()` functions have an argument, `na.rm` (NA remove) to indicate that missing values should be dropped in computing the value:

```{r}
mean(healthdata$pulse, na.rm=TRUE)
max(healthdata$pulse, na.rm=TRUE)
```

`min()`, `sd()`, `var()`, `median()` all also have an `na.rm` option.

How other functions handle missing values, and the name of the argument for handling missing values (if there is one) may be different. For example, to include missing values in a frequency table:

```{r}
table(healthdata$health_level)   # excludes missing values by default
table(healthdata$health_level, useNA = "ifany")
```

## TRY IT

Compute the mean and median of the first blood pressure measurements (`bp_sys1` and `bp_dia1`)

```{r}

```

## Counting Missing Values

We can identify missing values with the `is.na()` function, which returns `TRUE` where a value is missing and `FALSE` where the value is not missing:

```{r}
head(healthdata$health_level, n=20)
is.na(head(healthdata$health_level, n=20))
```

### Summing Boolean Values

A vector of TRUE and FALSE indicating which values are missing isn't that helpful to us. But we can use the `sum()` function to count the missing values. `sum()` will add numeric values, but it will also "add" logical/boolean values, counting TRUE as 1 and FALSE as 0

```{r}
# is.na() returns TRUE/FALSE
is.na(head(healthdata$health_level, n=20))

# count NA in the first 20 observations
sum(is.na(head(healthdata$health_level, n=20)))

# count NA over the whole vector
sum(is.na(healthdata$health_level))
```

## TRY IT

How many missing values are in the cholesterol variable?

What proportion of the values in the cholesterol variable are missing? Hint: what function can tell you how many values there are total in the cholesterol variable (how long the vector is)?

```{r}

```

## Not Missing

What if we want to see or count the observations that are NOT missing instead of those that are? We use the not operator `!`

```{r}
# is.na() returns TRUE/FALSE
is.na(head(healthdata$health_level, n=20))

# !is.na() returns the opposite
!is.na(head(healthdata$health_level, n=20))

# count not missing
sum(!is.na(head(healthdata$health_level, n=20)))
```

## Counting Missing Values for All Variables

`is.na()` will also work with a data frame as input:

```{r}
is.na(healthdata)
```

Combining this with the function `colSums()`, we can get a count of how many missing values are in each column:

```{r}
colSums(is.na(healthdata))
```
